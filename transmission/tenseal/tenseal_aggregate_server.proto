syntax = "proto3";


// client send it to requestServer
message local_params{
    int32 client_rank = 1;
    int32 sample_num = 2;
    bytes params_msg = 3;
}

message aggr_params{
    int32 client_rank = 1;
    bytes params_msg = 2;
}
//message aggr_params{
//    bytes params_msg = 1;
//}

message update_request{
  int32 client_rank = 1;
  int32 sample_num = 2;
}

message update_response{
  bool flag = 1;
  bytes params_msg = 2;
}

message intersection_request{
  int32 cid = 1;
  int32 qid = 2;
  repeated int32 request_msg = 3;
}

message intersection_response{
  int32 cid = 1;
  int32 qid = 2;
  repeated int32 response_msg = 3;
}

message identification_verify{
  int32 cid = 1;
  int32 qid = 2;
}

message intersection_sequence_index{
  int32 cid = 1;
  int32 qid = 2;
  int32 sequence_index = 3;
  int32 total_participator = 4;
}

message data_server_status_request{
  int32 cid = 1;
  int32 qid = 2;
  repeated string data_server_status = 3;
  int32 data_length = 4;
  bool carry_psi_final_result = 5;
  bytes psi_final_result = 6;
}

message agg_server_status_response{
  int32 cid = 1;
  int32 qid = 2;
  repeated string agg_server_status = 3;
  bool carry_psi_final_result = 4;
  bytes psi_final_result = 5;
}

service AggregateServerService {
  //  AggregateServer provides the interface, client remotes the call
  rpc sum_encrypted(local_params) returns (aggr_params);
  rpc boolean_is_update(update_request) returns(update_response);
  rpc get_intersection(intersection_request) returns(intersection_response);
  rpc get_intersection_sequence_index(identification_verify) returns (intersection_sequence_index);
  rpc get_agg_server_status(data_server_status_request) returns (agg_server_status_response);
}